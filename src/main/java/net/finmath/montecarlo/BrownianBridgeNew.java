/*
 * (c) Copyright Christian P. Fries, Germany. Contact: email@christian-fries.de.
 *
 * Created on 23.11.2013
 */

package net.finmath.montecarlo;

import net.finmath.equities.models.LNSVQD.LNSVQDUtils;
import net.finmath.randomnumbers.SobolSequence;
import net.finmath.stochastic.RandomVariable;
import net.finmath.time.TimeDiscretization;
import org.apache.commons.math3.random.SobolSequenceGenerator;

import java.io.IOException;
import java.util.*;

/**
 * This class implements a Brownian bridge, i.e., samples of realizations of a Brownian motion
 * conditional to a given start and end value.
 *
 * <p>
 * A Brownian bridge is a conditional Brownian motion, i.e. for given random variables
 * <i>X</i> and  <i>Y</i> the Brownian bridge is
 * <br>
 * <i>(W(t) | W(s) = X , W(T) = Y)</i>,
 * <br>
 * where <i>W</i> is a Brownian motion and <i>s &le; t &le; T</i>.
 * </p>
 * <p>
 * The samples of the Brownian bridge are generated by a Brownian motion which will be used to fill the gap between start and end.
 * It is important that this Browninan motion is independent from the one which generated start and end, i.e. here: it should have a different seed.
 * </p>
 * <p>
 * The class implements the {@code BrownianMotion}, i.e., it only provides the increments
 * of the Brownian bridge (however, in most application, like refinement of an Euler-scheme, this is
 * exactly the desired object).
 * </p>
 * <p>
 * Note: The number of paths needs to be specified, because the start and the end point
 * may be not stochastic, i.e. it is not possible to infer this quantity
 * from the specified start and end.
 * </p>
 *
 * @author Christian Fries
 * @version 1.0
 * @date 24.11.2013
 */
public class BrownianBridgeNew implements BrownianMotion {

	private final BrownianMotion generator;
	private final RandomVariable[] start;

	private final RandomVariableFactory randomVariableFactory = new RandomVariableFromArrayFactory();
	private final TimeDiscretization timeDiscretization;

	private transient RandomVariable[][] brownianIncrements;
	private transient double[][][] brownianIncrementsArray;
	private transient Object brownianIncrementsLazyInitLock = new Object();
	private int[][] schedulingArray;

	public BrownianBridgeNew(final BrownianMotion generator, final RandomVariable[] start, final TimeDiscretization timeDiscretization, int[][] schedulingArray) {
		this.generator = generator;
		this.start = start;
		this.timeDiscretization = timeDiscretization;
		this.schedulingArray = schedulingArray;
	}

	/**
	 * Construct a Brownian bridge, bridging from a given start to a given end.
	 *
	 * @param timeDiscretization The time discretization used for the Brownian increments.
	 * @param numberOfPaths      Number of paths to simulate.
	 * @param seed               The seed of the random number generator.
	 * @param start              Start value of the Brownian bridge.
	 */
	public BrownianBridgeNew(final TimeDiscretization timeDiscretization, final int numberOfPaths, final int seed, final RandomVariable[] start, int[][] schedulingArray) {
		this(new BrownianMotionFromMersenneRandomNumbers(timeDiscretization, start.length, numberOfPaths, seed), start, timeDiscretization, schedulingArray);
	}

	/**
	 * Construct a Brownian bridge, bridging from a given start to a given end.
	 *
	 * @param timeDiscretization The time discretization used for the Brownian increments.
	 * @param numberOfPaths      Number of paths to simulate.
	 * @param seed               The seed of the random number generator.
	 * @param start              Start value of the Brownian bridge.
	 * @param end                End value of the Brownian bridge.
	 */
	public BrownianBridgeNew(final TimeDiscretization timeDiscretization, final int numberOfPaths, final int seed, final RandomVariable start, final RandomVariable end, int[][] schedulingArray) {
		this(timeDiscretization, numberOfPaths, seed, new RandomVariable[]{start}, schedulingArray);
	}

	@Override
	public RandomVariable getBrownianIncrement(final int timeIndex, final int factor) {
		// Thread safe lazy initialization
		synchronized(brownianIncrementsLazyInitLock) {
			if(brownianIncrements == null) {
				doGenerateBrownianMotion(schedulingArray);
			}
		}

		/*
		 *  For performance reasons we return directly the stored data (no defensive copy).
		 *  We return an immutable object to ensure that the receiver does not alter the data.
		 */
		return brownianIncrements[timeIndex][factor];
	}

	public double[] getBrownianIncrementArr(final int timeIndex, final int factor, SobolSequence sobolSequenceGenerator, int seed) {
		// Thread safe lazy initialization
		synchronized(brownianIncrementsLazyInitLock) {
			if(brownianIncrementsArray == null) {
				doGenerateBrownianMotionNewFirstOverPaths(schedulingArray, sobolSequenceGenerator, seed);
			}
		}

		/*
		 *  For performance reasons we return directly the stored data (no defensive copy).
		 *  We return an immutable object to ensure that the receiver does not alter the data.
		 */
		return brownianIncrementsArray[timeIndex][factor];
	}

	/**
	 * Lazy initialization of brownianIncrement. Synchronized to ensure thread safety of lazy init.
	 */
	private void doGenerateBrownianMotion(int[][] schedulingArray) {
		if(brownianIncrements != null) {
			return;    // Nothing to do
		}

		// Allocate memory
		brownianIncrements = new RandomVariable[getTimeDiscretization().getNumberOfTimeSteps()][generator.getNumberOfFactors()];

		/**
		 * STEP 1: Create disc. Brownian motion
		 */
		RandomVariable[][] brownianMotion = new RandomVariable[getTimeDiscretization().getNumberOfTimes()][generator.getNumberOfFactors()];
		brownianMotion[0] = start;

		for(int j = 1; j < brownianMotion.length; j++) {
			int timeIndex = schedulingArray[j][0];
			double time = timeDiscretization.getTime(timeIndex);

			int timeIndexEarlierTimeStep = schedulingArray[j][1];
			double timeEarlier = timeDiscretization.getTime(timeIndexEarlierTimeStep);

			int timeIndexLaterTimeStep = schedulingArray[j][2];
			double timeLater = timeDiscretization.getTime(timeIndexLaterTimeStep);

			double fac = (time - timeEarlier) / (timeLater - timeEarlier);

			for(int componentIndex = 0; componentIndex < 2; componentIndex++) {
				RandomVariable standardNormal = generator.getBrownianIncrement(j - 1, componentIndex);
				/*LNSVQDUtils.printArrayVertical(standardNormal.getRealizations());*/
				if(j == 1) {
					brownianMotion[timeIndex][componentIndex] =
							brownianMotion[timeIndexEarlierTimeStep][componentIndex]
									.add(standardNormal.mult(Math.sqrt(time)));
				} else {
					brownianMotion[timeIndex][componentIndex] =
							brownianMotion[timeIndexEarlierTimeStep][componentIndex]
									.add(brownianMotion[timeIndexLaterTimeStep][componentIndex].sub(brownianMotion[timeIndexEarlierTimeStep][componentIndex]).mult(fac))
									.add(standardNormal.mult(Math.sqrt(fac * (timeLater - time))));
				}
			}
		}

		for(int j = 0; j < brownianIncrements.length; j++) {
			for(int i = 0; i < brownianIncrements[0].length; i++)
				brownianIncrements[j][i] = brownianMotion[j + 1][i].sub(brownianMotion[j][i]);
		}
	}

	private void doGenerateBrownianMotionNew(int[][] schedulingArray) {
		if(brownianIncrementsArray != null) {
			return;    // Nothing to do
		}

		// Allocate memory
		brownianIncrementsArray = new double[getTimeDiscretization().getNumberOfTimeSteps()][generator.getNumberOfFactors()][getNumberOfPaths()];

		/**
		 * STEP 1: Create disc. Brownian motion
		 */
		/*RandomVariable[][] brownianMotion = new RandomVariable[getTimeDiscretization().getNumberOfTimes()][generator.getNumberOfFactors()];
		brownianMotion[0] = start;*/

		double[][][] brownianMotionArr = new double[getTimeDiscretization().getNumberOfTimes()][generator.getNumberOfFactors()][getNumberOfPaths()];
		double[][] initArray = new double[generator.getNumberOfFactors()][getNumberOfPaths()];
		for(int i = 0; i < initArray.length; i++) {
			Arrays.fill(initArray[i], 0);  // Fill each row with 0s
		}
		brownianMotionArr[0] = initArray;

		for(int j = 1; j < brownianMotionArr.length; j++) {
			int timeIndex = schedulingArray[j][0];
			double time = timeDiscretization.getTime(timeIndex);

			int timeIndexEarlierTimeStep = schedulingArray[j][1];
			double timeEarlier = timeDiscretization.getTime(timeIndexEarlierTimeStep);

			int timeIndexLaterTimeStep = schedulingArray[j][2];
			double timeLater = timeDiscretization.getTime(timeIndexLaterTimeStep);

			double fac = (time - timeEarlier) / (timeLater - timeEarlier);

			for(int componentIndex = 0; componentIndex < 2; componentIndex++) {
				double[] standardNormal = generator.getBrownianIncrement(j - 1, componentIndex).getRealizations();
				/*LNSVQDUtils.printArrayVertical(standardNormal.getRealizations());*/
				for(int p = 0; p < getNumberOfPaths(); p++) {
					if(j == 1) {
						/*brownianMotion[timeIndex][componentIndex] =
								brownianMotion[timeIndexEarlierTimeStep][componentIndex]
										.add(standardNormal.mult(Math.sqrt(time)));*/
						brownianMotionArr[timeIndex][componentIndex][p] =
								brownianMotionArr[timeIndexEarlierTimeStep][componentIndex][p] + standardNormal[p] * Math.sqrt(time);
					} else {
						/*brownianMotion[timeIndex][componentIndex] =
								brownianMotion[timeIndexEarlierTimeStep][componentIndex]
										.add(brownianMotion[timeIndexLaterTimeStep][componentIndex].sub(brownianMotion[timeIndexEarlierTimeStep][componentIndex]).mult(fac))
										.add(standardNormal.mult(Math.sqrt(fac * (timeLater - time))));*/
						brownianMotionArr[timeIndex][componentIndex][p] =
								brownianMotionArr[timeIndexEarlierTimeStep][componentIndex][p]
										+ ((brownianMotionArr[timeIndexLaterTimeStep][componentIndex][p] - brownianMotionArr[timeIndexEarlierTimeStep][componentIndex][p]) * fac)
										+ (standardNormal[p] * Math.sqrt(fac * (timeLater - time)));
					}
				}
			}
		}

		double[] brownianMotionLastTime; //  = brownianMotion[j + 1][i].getRealizations();
		double[] brownianMotionCurrentTime;
		for(int j = 0; j < getTimeDiscretization().getNumberOfTimeSteps(); j++) {
			for(int i = 0; i < generator.getNumberOfFactors(); i++) {
				brownianMotionLastTime = brownianMotionArr[j][i];
				brownianMotionCurrentTime = brownianMotionArr[j + 1][i];
				// brownianIncrements[j][i] = brownianMotion[j + 1][i].sub(brownianMotion[j][i]);
				for(int p = 0; p < getNumberOfPaths(); p++) {
					brownianIncrementsArray[j][i][p] = brownianMotionCurrentTime[p] - brownianMotionLastTime[p];
				}
			}
		}
	}

	private void doGenerateBrownianMotionNewFirstOverPaths(int[][] schedulingArray, SobolSequence sobolSequenceGenerator, int seed) {
		Random random = new Random((long) seed); // Convert seed to long
		double scrambleNumber =  random.nextDouble();

		if(brownianIncrementsArray != null) {
			return;    // Nothing to do
		}

		// Allocate memory
		brownianIncrementsArray = new double[getTimeDiscretization().getNumberOfTimeSteps()][generator.getNumberOfFactors()][getNumberOfPaths()];

		/**
		 * STEP 1: Create disc. Brownian motion
		 */
		/*RandomVariable[][] brownianMotion = new RandomVariable[getTimeDiscretization().getNumberOfTimes()][generator.getNumberOfFactors()];
		brownianMotion[0] = start;*/

		double[][][] brownianMotionArr = new double[getTimeDiscretization().getNumberOfTimes()][generator.getNumberOfFactors()][getNumberOfPaths()];
		double[][] initArray = new double[generator.getNumberOfFactors()][getNumberOfPaths()];
		for(int i = 0; i < initArray.length; i++) {
			Arrays.fill(initArray[i], 0);  // Fill each row with 0s
		}
		brownianMotionArr[0] = initArray;

		for(int p = 0; p < getNumberOfPaths(); p++) {
			double[] vec = sobolSequenceGenerator.generator.nextVector();
			double[] standardNormals = LNSVQDUtils.getStdNormalsFromUnifVec(vec, scrambleNumber);
			double[] standardAsset = new double[standardNormals.length / 2];
			double[] standardVol = new double[standardNormals.length / 2];
			for(int o = 0; o < standardNormals.length / 2; o++) {
				standardAsset[o] = standardNormals[2 * o];
				standardVol[o] = standardNormals[2 * o + 1];
			}

			/*LNSVQDUtils.printArrayVertical(standardNormals);*/

			for(int j = 1; j < brownianMotionArr.length; j++) {
				int timeIndex = schedulingArray[j][0];
				double time = timeDiscretization.getTime(timeIndex);

				int timeIndexEarlierTimeStep = schedulingArray[j][1];
				double timeEarlier = timeDiscretization.getTime(timeIndexEarlierTimeStep);

				int timeIndexLaterTimeStep = schedulingArray[j][2];
				double timeLater = timeDiscretization.getTime(timeIndexLaterTimeStep);

				double fac = (time - timeEarlier) / (timeLater - timeEarlier);

				for(int componentIndex = 0; componentIndex < 2; componentIndex++) {
					double[] standardNormal;
					if(componentIndex == 0) {
						standardNormal = standardAsset;
					} else {
						standardNormal = standardVol;
					}

					if(j == 1) {
						/*brownianMotion[timeIndex][componentIndex] =
								brownianMotion[timeIndexEarlierTimeStep][componentIndex]
										.add(standardNormal.mult(Math.sqrt(time)));*/
						brownianMotionArr[timeIndex][componentIndex][p] =
								brownianMotionArr[timeIndexEarlierTimeStep][componentIndex][p] + standardNormal[j - 1] * Math.sqrt(time);
					} else {
						/*brownianMotion[timeIndex][componentIndex] =
								brownianMotion[timeIndexEarlierTimeStep][componentIndex]
										.add(brownianMotion[timeIndexLaterTimeStep][componentIndex].sub(brownianMotion[timeIndexEarlierTimeStep][componentIndex]).mult(fac))
										.add(standardNormal.mult(Math.sqrt(fac * (timeLater - time))));*/
						brownianMotionArr[timeIndex][componentIndex][p] =
								brownianMotionArr[timeIndexEarlierTimeStep][componentIndex][p]
										+ ((brownianMotionArr[timeIndexLaterTimeStep][componentIndex][p] - brownianMotionArr[timeIndexEarlierTimeStep][componentIndex][p]) * fac)
										+ (standardNormal[j - 1] * Math.sqrt(fac * (timeLater - time)));
					}
				}
			}
		}

		double[] brownianMotionLastTime; //  = brownianMotion[j + 1][i].getRealizations();
		double[] brownianMotionCurrentTime;
		for(int j = 0; j < getTimeDiscretization().getNumberOfTimeSteps(); j++) {
			for(int i = 0; i < generator.getNumberOfFactors(); i++) {
				brownianMotionLastTime = brownianMotionArr[j][i];
				brownianMotionCurrentTime = brownianMotionArr[j + 1][i];
				// brownianIncrements[j][i] = brownianMotion[j + 1][i].sub(brownianMotion[j][i]);
				for(int p = 0; p < getNumberOfPaths(); p++) {
					brownianIncrementsArray[j][i][p] = brownianMotionCurrentTime[p] - brownianMotionLastTime[p];
				}
			}
		}
	}


	/* (non-Javadoc)
	 * @see net.finmath.montecarlo.BrownianMotion#getTimeDiscretization()
	 */
	@Override
	public TimeDiscretization getTimeDiscretization() {
		return timeDiscretization;
	}

	/* (non-Javadoc)
	 * @see net.finmath.montecarlo.BrownianMotion#getNumberOfFactors()
	 */
	@Override
	public int getNumberOfFactors() {
		return generator.getNumberOfFactors();
	}

	/* (non-Javadoc)
	 * @see net.finmath.montecarlo.BrownianMotion#getNumberOfPaths()
	 */
	@Override
	public int getNumberOfPaths() {
		return generator.getNumberOfPaths();
	}

	@Override
	public RandomVariable getRandomVariableForConstant(final double value) {
		return randomVariableFactory.createRandomVariable(value);
	}

	/* (non-Javadoc)
	 * @see net.finmath.montecarlo.BrownianMotion#getCloneWithModifiedSeed(int)
	 */
	@Override
	public BrownianMotion getCloneWithModifiedSeed(final int seed) {
		return new BrownianBridgeNew(getTimeDiscretization(), getNumberOfPaths(), seed, start, schedulingArray);
	}

	/* (non-Javadoc)
	 * @see net.finmath.montecarlo.BrownianMotion#getCloneWithModifiedTimeDiscretization(net.finmath.time.TimeDiscretization)
	 */
	@Override
	public BrownianMotion getCloneWithModifiedTimeDiscretization(final TimeDiscretization newTimeDiscretization) {
		return null; // new BrownianBridge(generator.getCloneWithModifiedTimeDiscretization(newTimeDiscretization), start, end);
	}

	@Override
	public RandomVariable[] getIncrement(final int timeIndex) {
		// Thread safe lazy initialization
		synchronized(brownianIncrementsLazyInitLock) {
			if(brownianIncrements == null) {
				doGenerateBrownianMotion(schedulingArray);
			}
		}

		return brownianIncrements[timeIndex].clone();
	}

	@Override
	public RandomVariable getIncrement(final int timeIndex, final int factor) {
		return getBrownianIncrement(timeIndex, factor);
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return "BrownianBridge [generator=" + generator
				+ Arrays.toString(start) + ", end=" + Arrays.toString(start) // TODO: Change
				+ "]";
	}

	private void readObject(final java.io.ObjectInputStream in) throws ClassNotFoundException, IOException {
		in.defaultReadObject();
		// initialization of transients
		brownianIncrementsLazyInitLock = new Object();
	}
}
